//
// Generated by Bluespec Compiler, version 2024.01 (build ae2a2fc6)
//
// On Fri Apr  4 18:23:33 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// read_csr                       O    32
// RDY_read_csr                   O     1 const
// RDY_write_csr                  O     1 const
// upd_on_ret                     O    32
// RDY_upd_on_ret                 O     1 const
// upd_on_trap                    O    32
// RDY_upd_on_trap                O     1 const
// RDY_incr_minstret              O     1 const
// mv_csr_decode                  O    84
// RDY_mv_csr_decode              O     1 const
// mv_csr_misa_c                  O     1 const
// RDY_mv_csr_misa_c              O     1 const
// mv_curr_priv                   O     2 reg
// RDY_mv_curr_priv               O     1 const
// csr_mstatus                    O    32
// RDY_csr_mstatus                O     1 const
// RDY_clint_msip                 O     1 const
// RDY_clint_mtip                 O     1 const
// RDY_clint_mtime                O     1 const
// RDY_ext_interrupt              O     1 const
// mv_interrupt                   O     1
// CLK                            I     1 clock
// RST_N                          I     1 reset
// read_csr_addr                  I    12
// write_csr_addr                 I    12
// write_csr_word                 I    32
// write_csr_lpc                  I     2 unused
// upd_on_trap_cause              I     6
// upd_on_trap_pc                 I    32
// upd_on_trap_tval               I    32
// clint_msip_intrpt              I     1 reg
// clint_mtip_intrpt              I     1 reg
// clint_mtime_c_mtime            I    64 reg
// ext_interrupt_ex_i             I     1 reg
// EN_write_csr                   I     1
// EN_incr_minstret               I     1
// EN_clint_msip                  I     1
// EN_clint_mtip                  I     1
// EN_clint_mtime                 I     1
// EN_ext_interrupt               I     1
// EN_read_csr                    I     1 unused
// EN_upd_on_ret                  I     1
// EN_upd_on_trap                 I     1
//
// Combinational paths from inputs to outputs:
//   read_csr_addr -> read_csr
//   upd_on_trap_cause -> upd_on_trap
//
//
`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif
//
// Simplified CSR File (RV32I-only, minimal features)
// - Removed MISA, MSCRATCH, MTIME, privilege levels
// - Simplified MSTATUS/MIE/MIP to single-bit
// - Fixed MTVEC address (0x0)
// - Basic trap/interrupt handling
//
module mkcsrfile(CLK,
     RST_N,

     read_csr_addr,
     EN_read_csr,
     read_csr,
     RDY_read_csr,

     write_csr_addr,
     write_csr_word,
     EN_write_csr,
     RDY_write_csr,

     EN_upd_on_ret,
     upd_on_ret,
     RDY_upd_on_ret,

     upd_on_trap_cause,
     upd_on_trap_pc,
     EN_upd_on_trap,
     upd_on_trap,
     RDY_upd_on_trap,

     ext_interrupt_ex_i,
     EN_ext_interrupt,
     RDY_ext_interrupt,
     csr_mstatus,
     mv_interrupt);

  input  CLK;
  input  RST_N;

  // CSR access ports
  input  [11 : 0] read_csr_addr;
  input  EN_read_csr;
  output [31 : 0] read_csr;
  output RDY_read_csr;

  input  [11 : 0] write_csr_addr;
  input  [31 : 0] write_csr_word;
  input  EN_write_csr;
  output RDY_write_csr;

  // Trap handling
  input  EN_upd_on_ret;
  output [31 : 0] upd_on_ret;
  output RDY_upd_on_ret;

  input  [5 : 0] upd_on_trap_cause;
  input  [31 : 0] upd_on_trap_pc;
  input  EN_upd_on_trap;
  output [31 : 0] upd_on_trap;
  output RDY_upd_on_trap;

  // Interrupts
  input  ext_interrupt_ex_i;
  input  EN_ext_interrupt;
  output RDY_ext_interrupt;
  output mv_interrupt;
  output [31:0] csr_mstatus;

  // Internal registers
  reg [3 : 0]  rg_mcause;    // 4-bit cause (supports 16 exceptions)
  reg [31 : 0] rg_mepc;      // Full 32-bit PC (no alignment bit)
  reg          rg_mie;       // Single-bit global interrupt enable
  reg          rg_mip;       // Single-bit interrupt pending

  // Fixed MTVEC address (hardcoded to 0x0)
  assign upd_on_trap = 32'h00000000;

  // CSR read logic
  assign read_csr = 
    (read_csr_addr == 12'h300) ? {31'd0, rg_mie} : // MSTATUS
    (read_csr_addr == 12'h341) ? rg_mepc :         // MEPC
    (read_csr_addr == 12'h342) ? {28'd0, rg_mcause} : // MCAUSE
    32'd0;

  assign RDY_read_csr = 1'b1;

  // CSR write logic (only MSTATUS/MEPC supported)
  always @(posedge CLK or negedge RST_N) begin
    if (!RST_N) begin
      rg_mie   <= 1'b0;
      rg_mepc  <= 32'd0;
      rg_mcause <= 4'd0;
      rg_mip   <= 1'b0;
    end else begin
      if (EN_write_csr) begin
        case (write_csr_addr)
          12'h300: rg_mie <= write_csr_word[0]; // MSTATUS[0] = MIE
          12'h341: rg_mepc <= write_csr_word;   // MEPC
          12'h342: rg_mcause <= write_csr_word[3:0]; // MCAUSE
        endcase
      end

      // Interrupt pending (simple OR)
      if (EN_ext_interrupt) begin
        rg_mip <= ext_interrupt_ex_i;
      end
    end
  end

  // Trap handling
  assign upd_on_ret = rg_mepc;
  assign RDY_upd_on_ret = 1'b1;
  assign RDY_upd_on_trap = 1'b1;

  // Interrupt generation
  assign mv_interrupt = rg_mip & rg_mie;

  // Unused feature tie-offs
  assign RDY_write_csr = 1'b1;
  assign RDY_ext_interrupt = 1'b1;
  assign csr_mstatus = {31'd0, rg_mie};

endmodule