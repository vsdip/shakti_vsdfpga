//
// Generated by Bluespec Compiler, version 2024.01 (build ae2a2fc6)
//
// On Fri Apr  4 18:23:31 IST 2025
//
//
// Ports:
// Name                         I/O  size props
// inst_request_get               O    34
// RDY_inst_request_get           O     1
// RDY_inst_response_put          O     1 reg
// tx_stage1_operands_enq_ena     O     1
// tx_stage1_operands_enq_data    O    64
// tx_stage1_meta_enq_ena         O     1
// tx_stage1_meta_enq_data        O    62
// tx_stage1_control_enq_ena      O     1
// tx_stage1_control_enq_data     O    34 reg
// tx_stage1_dump_enq_ena         O     1
// tx_stage1_dump_enq_data        O    64
// RDY_commit_rd_put              O     1
// RDY_ma_update_eEpoch           O     1 const
// RDY_ma_update_wEpoch           O     1 const
// resetpc                        I    32
// CLK                            I     1 clock
// RST_N                          I     1 reset
// inst_response_put              I    35 reg
// tx_stage1_operands_notFull_b   I     1 unused
// tx_stage1_operands_enq_rdy_b   I     1
// tx_stage1_meta_notFull_b       I     1 unused
// tx_stage1_meta_enq_rdy_b       I     1
// tx_stage1_control_notFull_b    I     1 unused
// tx_stage1_control_enq_rdy_b    I     1
// tx_stage1_dump_notFull_b       I     1 unused
// tx_stage1_dump_enq_rdy_b       I     1
// commit_rd_put                  I    37
// ma_flush_newpc                 I    32
// ma_csr_misa_c_c                I     1 unused
// ma_interrupt_i                 I     1
// ma_csr_decode_c                I    84
// EN_inst_response_put           I     1
// EN_commit_rd_put               I     1
// EN_ma_flush                    I     1
// EN_ma_update_eEpoch            I     1
// EN_ma_update_wEpoch            I     1
// EN_inst_request_get            I     1
//
// Combinational paths from inputs to outputs:
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    tx_stage1_dump_enq_rdy_b,
//    ma_csr_decode_c,
//    EN_ma_flush) -> tx_stage1_operands_enq_ena
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    tx_stage1_dump_enq_rdy_b,
//    commit_rd_put,
//    ma_csr_decode_c,
//    EN_commit_rd_put,
//    EN_ma_flush) -> tx_stage1_operands_enq_data
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    tx_stage1_dump_enq_rdy_b,
//    ma_csr_decode_c,
//    EN_ma_flush) -> tx_stage1_meta_enq_ena
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    tx_stage1_dump_enq_rdy_b,
//    ma_csr_decode_c,
//    EN_ma_flush) -> tx_stage1_meta_enq_data
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    tx_stage1_dump_enq_rdy_b,
//    ma_csr_decode_c,
//    EN_ma_flush) -> tx_stage1_control_enq_ena
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    tx_stage1_dump_enq_rdy_b,
//    ma_csr_decode_c,
//    EN_ma_flush) -> tx_stage1_control_enq_data
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    tx_stage1_dump_enq_rdy_b,
//    ma_csr_decode_c,
//    EN_ma_flush) -> tx_stage1_dump_enq_ena
//   (tx_stage1_operands_enq_rdy_b,
//    tx_stage1_meta_enq_rdy_b,
//    tx_stage1_control_enq_rdy_b,
//    tx_stage1_dump_enq_rdy_b,
//    ma_csr_decode_c,
//    EN_ma_flush) -> tx_stage1_dump_enq_data
//
//
// module: This Module implements the instruction-fetch + decode + operand-fetch   functionality of the pipeline.     1. Instruction-Fetch phase:  It generates the new PC, sends the PC to the fabric and in   return expects the instruction response from the fabric. The PC is updated  either when a flush is received from any of the later stages or is simple incremented by 4 or 2  (in case of compressed instructions)    2. Decode phase: Once the instruction is received, it is checked if the instruction is a  compressed instruction or not. If so, then it passes through a decompressor which then converts  the compressed instruction into its 32-bit equivalent encoding. The 32-bit instructions are  then decoded to capture various informations. Most of the decoded information which holds  control-flow information is passed on to the next stage for execution.    3. Operand Fetch: The operand addresses are generated by the decoder and then used to access the  register file. The registerfile itself forward the data of the commit happening in the same  cycle. The fetched operands are then passed on to the next stage.    4. The debugger also is given access to the registerfile through this module.    5. Triggers are also supported to capture events related to program counter or instruction match
//
// Comments on the inlined module `integer_rf':
//   submod: operand register file
//
// Comments on the inlined module `wr_interrupt':
//   wire: This wire will be set if any interrupts have been detected by the core
//
// Comments on the inlined module `wr_csr_decode':
//   wire: this wire caries the current value of certain csrs
//
// Comments on the inlined module `wr_csr_misa_c':
//   wire: this wire carries the current value of the misa_c csr field
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkstage1(resetpc,
		CLK,
		RST_N,

		EN_inst_request_get,
		inst_request_get,
		RDY_inst_request_get,

		inst_response_put,
		EN_inst_response_put,
		RDY_inst_response_put,

		tx_stage1_operands_notFull_b,

		tx_stage1_operands_enq_rdy_b,

		tx_stage1_operands_enq_ena,

		tx_stage1_operands_enq_data,

		tx_stage1_meta_notFull_b,

		tx_stage1_meta_enq_rdy_b,

		tx_stage1_meta_enq_ena,

		tx_stage1_meta_enq_data,

		tx_stage1_control_notFull_b,

		tx_stage1_control_enq_rdy_b,

		tx_stage1_control_enq_ena,

		tx_stage1_control_enq_data,

		tx_stage1_dump_notFull_b,

		tx_stage1_dump_enq_rdy_b,

		tx_stage1_dump_enq_ena,

		tx_stage1_dump_enq_data,

		commit_rd_put,
		EN_commit_rd_put,
		RDY_commit_rd_put,

		ma_flush_newpc,
		EN_ma_flush,

		ma_csr_misa_c_c,

		ma_interrupt_i,

		ma_csr_decode_c,

		EN_ma_update_eEpoch,
		RDY_ma_update_eEpoch,

		EN_ma_update_wEpoch,
		RDY_ma_update_wEpoch);
  input  [31 : 0] resetpc;
  input  CLK;
  input  RST_N;

  // actionvalue method inst_request_get
  input  EN_inst_request_get;
  output [33 : 0] inst_request_get;
  output RDY_inst_request_get;

  // action method inst_response_put
  input  [34 : 0] inst_response_put;
  input  EN_inst_response_put;
  output RDY_inst_response_put;

  // action method tx_stage1_operands_notFull
  input  tx_stage1_operands_notFull_b;

  // action method tx_stage1_operands_enq_rdy
  input  tx_stage1_operands_enq_rdy_b;

  // value method tx_stage1_operands_enq_ena
  output tx_stage1_operands_enq_ena;

  // value method tx_stage1_operands_enq_data
  output [63 : 0] tx_stage1_operands_enq_data;

  // action method tx_stage1_meta_notFull
  input  tx_stage1_meta_notFull_b;

  // action method tx_stage1_meta_enq_rdy
  input  tx_stage1_meta_enq_rdy_b;

  // value method tx_stage1_meta_enq_ena
  output tx_stage1_meta_enq_ena;

  // value method tx_stage1_meta_enq_data
  output [61 : 0] tx_stage1_meta_enq_data;

  // action method tx_stage1_control_notFull
  input  tx_stage1_control_notFull_b;

  // action method tx_stage1_control_enq_rdy
  input  tx_stage1_control_enq_rdy_b;

  // value method tx_stage1_control_enq_ena
  output tx_stage1_control_enq_ena;

  // value method tx_stage1_control_enq_data
  output [33 : 0] tx_stage1_control_enq_data;

  // action method tx_stage1_dump_notFull
  input  tx_stage1_dump_notFull_b;

  // action method tx_stage1_dump_enq_rdy
  input  tx_stage1_dump_enq_rdy_b;

  // value method tx_stage1_dump_enq_ena
  output tx_stage1_dump_enq_ena;

  // value method tx_stage1_dump_enq_data
  output [63 : 0] tx_stage1_dump_enq_data;

  // action method commit_rd_put
  input  [36 : 0] commit_rd_put;
  input  EN_commit_rd_put;
  output RDY_commit_rd_put;

  // action method ma_flush
  input  [31 : 0] ma_flush_newpc;
  input  EN_ma_flush;

  // action method ma_csr_misa_c
  input  ma_csr_misa_c_c;

  // action method ma_interrupt
  input  ma_interrupt_i;

  // action method ma_csr_decode
  input  [83 : 0] ma_csr_decode_c;

  // action method ma_update_eEpoch
  input  EN_ma_update_eEpoch;
  output RDY_ma_update_eEpoch;

  // action method ma_update_wEpoch
  input  EN_ma_update_wEpoch;
  output RDY_ma_update_wEpoch;

  // signals for module outputs
  wire [63 : 0] tx_stage1_dump_enq_data, tx_stage1_operands_enq_data;
  wire [61 : 0] tx_stage1_meta_enq_data;
  wire [33 : 0] inst_request_get, tx_stage1_control_enq_data;
  wire RDY_commit_rd_put,
       RDY_inst_request_get,
       RDY_inst_response_put,
       RDY_ma_update_eEpoch,
       RDY_ma_update_wEpoch,
       tx_stage1_control_enq_ena,
       tx_stage1_dump_enq_ena,
       tx_stage1_meta_enq_ena,
       tx_stage1_operands_enq_ena;

  // inlined wires
  wire [31 : 0] rg_fabric_request_port0__write_1,
		rg_fabric_request_port1__read,
		rg_fabric_request_port1__write_1,
		rg_fabric_request_port2__read;
  wire integer_rf_wr_write_address_whas,
       integer_rf_wr_write_data_whas,
       rg_fabric_request_EN_port1__write;

  // register rg_action
  // reg: This register implements a simple state - machine which indicates how the     instruction should be extracted from the cache response.
  reg rg_action;
  wire rg_action_D_IN, rg_action_EN;

  // register rg_eEpoch
  // reg: holds the current epoch values controlled by the stage2.
  reg rg_eEpoch;
  wire rg_eEpoch_D_IN, rg_eEpoch_EN;

  // register rg_fabric_request
  // reg: register to hold the address of the next request to the fabric.
  reg [31 : 0] rg_fabric_request;
  wire [31 : 0] rg_fabric_request_D_IN;
  wire rg_fabric_request_EN;

  // register rg_index
  // reg: index into the Regfile during initialization sequence.
  reg [4 : 0] rg_index;
  wire [4 : 0] rg_index_D_IN;
  wire rg_index_EN;

  // register rg_initialize
  // reg: register to indicate that the RegFile is being initialized to all zeros
  reg rg_initialize;
  wire rg_initialize_D_IN, rg_initialize_EN;

  // register rg_pc
  // reg: register to hold the PC value of the instruction to be decoded.
  reg [31 : 0] rg_pc;
  reg [31 : 0] rg_pc_D_IN;
  wire rg_pc_EN;

  // register rg_wEpoch
  // reg: holds the current epoch values controlled by the stage3.
  reg rg_wEpoch;
  wire rg_wEpoch_D_IN, rg_wEpoch_EN;

  // register rg_wfi
  // reg: this is register it set to True when a WFI instruction is executed. It set to     False, when an interrupt has been received or there is a flush from the write - back stage.
  reg rg_wfi;
  wire rg_wfi_D_IN, rg_wfi_EN;

  // ports of submodule ff_memory_response
  wire [34 : 0] ff_memory_response_D_IN, ff_memory_response_D_OUT;
  wire ff_memory_response_CLR,
       ff_memory_response_DEQ,
       ff_memory_response_EMPTY_N,
       ff_memory_response_ENQ,
       ff_memory_response_FULL_N;

  // ports of submodule integer_rf_rf
  wire [31 : 0] integer_rf_rf_D_IN,
		integer_rf_rf_D_OUT_1,
		integer_rf_rf_D_OUT_2;
  wire [4 : 0] integer_rf_rf_ADDR_1,
	       integer_rf_rf_ADDR_2,
	       integer_rf_rf_ADDR_3,
	       integer_rf_rf_ADDR_4,
	       integer_rf_rf_ADDR_5,
	       integer_rf_rf_ADDR_IN;
  wire integer_rf_rf_WE;

  // rule scheduling signals
  wire CAN_FIRE_RL_initialize_regfile,
       CAN_FIRE_RL_process_instruction,
       CAN_FIRE_RL_wait_for_interrupt,
       CAN_FIRE_commit_rd_put,
       CAN_FIRE_inst_request_get,
       CAN_FIRE_inst_response_put,
       CAN_FIRE_ma_csr_decode,
       CAN_FIRE_ma_csr_misa_c,
       CAN_FIRE_ma_flush,
       CAN_FIRE_ma_interrupt,
       CAN_FIRE_ma_update_eEpoch,
       CAN_FIRE_ma_update_wEpoch,
       CAN_FIRE_tx_stage1_control_enq_rdy,
       CAN_FIRE_tx_stage1_control_notFull,
       CAN_FIRE_tx_stage1_dump_enq_rdy,
       CAN_FIRE_tx_stage1_dump_notFull,
       CAN_FIRE_tx_stage1_meta_enq_rdy,
       CAN_FIRE_tx_stage1_meta_notFull,
       CAN_FIRE_tx_stage1_operands_enq_rdy,
       CAN_FIRE_tx_stage1_operands_notFull,
       WILL_FIRE_RL_initialize_regfile,
       WILL_FIRE_RL_process_instruction,
       WILL_FIRE_RL_wait_for_interrupt,
       WILL_FIRE_commit_rd_put,
       WILL_FIRE_inst_request_get,
       WILL_FIRE_inst_response_put,
       WILL_FIRE_ma_csr_decode,
       WILL_FIRE_ma_csr_misa_c,
       WILL_FIRE_ma_flush,
       WILL_FIRE_ma_interrupt,
       WILL_FIRE_ma_update_eEpoch,
       WILL_FIRE_ma_update_wEpoch,
       WILL_FIRE_tx_stage1_control_enq_rdy,
       WILL_FIRE_tx_stage1_control_notFull,
       WILL_FIRE_tx_stage1_dump_enq_rdy,
       WILL_FIRE_tx_stage1_dump_notFull,
       WILL_FIRE_tx_stage1_meta_enq_rdy,
       WILL_FIRE_tx_stage1_meta_notFull,
       WILL_FIRE_tx_stage1_operands_enq_rdy,
       WILL_FIRE_tx_stage1_operands_notFull;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_rg_fabric_request_port1__write_1__VAL_2,
		MUX_rg_pc_write_1__VAL_1;
  wire MUX_rg_fabric_request_port1__write_1__SEL_1,
       MUX_rg_pc_write_1__SEL_1,
       MUX_rg_wfi_write_1__SEL_1;

  // declarations used by system tasks
  // synopsys translate_off
  reg TASK_testplusargs___d133;
  reg TASK_testplusargs___d134;
  reg TASK_testplusargs___d135;
  reg [63 : 0] v__h4560;
  reg TASK_testplusargs___d143;
  reg TASK_testplusargs___d144;
  reg TASK_testplusargs___d145;
  reg [63 : 0] v__h4862;
  reg TASK_testplusargs___d2;
  reg TASK_testplusargs___d3;
  reg TASK_testplusargs___d4;
  reg [63 : 0] v__h2173;
  reg TASK_testplusargs___d17;
  reg TASK_testplusargs___d18;
  reg TASK_testplusargs___d19;
  reg [63 : 0] v__h2552;
  reg TASK_testplusargs___d44;
  reg TASK_testplusargs___d45;
  reg TASK_testplusargs___d46;
  reg [63 : 0] v__h2746;
  reg TASK_testplusargs___d101;
  reg TASK_testplusargs___d102;
  reg TASK_testplusargs___d103;
  reg [63 : 0] v__h3486;
  reg TASK_testplusargs___d108;
  reg TASK_testplusargs___d109;
  reg TASK_testplusargs___d110;
  reg [63 : 0] v__h3628;
  reg NOT_rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_mem_ETC___d49;
  reg NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d106;
  reg NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d113;
  // synopsys translate_on

  // remaining internal signals
  wire [61 : 0] decoder_func_32___d66;
  wire [31 : 0] final_instruction__h2887,
		v__h2828,
		x__h3155,
		x__h3181,
		x__read__h987,
		x_wget__h976;
  wire [11 : 0] x__h2991;
  wire [7 : 0] chk_interrupt___d57;
  wire [6 : 0] _theResult___fst__h3006,
	       func_cause___1__h2999,
	       x1_avValue_meta_funct__h2931;
  wire [4 : 0] x__read__h916, x_wget__h905;
  wire [2 : 0] IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68;
  wire [1 : 0] curr_epoch__h2083;
  wire rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42;

  // actionvalue method inst_request_get
  assign inst_request_get = { rg_fabric_request, curr_epoch__h2083 } ;
  assign RDY_inst_request_get = !rg_initialize ;
  assign CAN_FIRE_inst_request_get = !rg_initialize ;
  assign WILL_FIRE_inst_request_get = EN_inst_request_get ;

  // action method inst_response_put
  assign RDY_inst_response_put = ff_memory_response_FULL_N ;
  assign CAN_FIRE_inst_response_put = ff_memory_response_FULL_N ;
  assign WILL_FIRE_inst_response_put = EN_inst_response_put ;

  // action method tx_stage1_operands_notFull
  assign CAN_FIRE_tx_stage1_operands_notFull = 1'd1 ;
  assign WILL_FIRE_tx_stage1_operands_notFull = 1'd1 ;

  // action method tx_stage1_operands_enq_rdy
  assign CAN_FIRE_tx_stage1_operands_enq_rdy = 1'd1 ;
  assign WILL_FIRE_tx_stage1_operands_enq_rdy = 1'd1 ;

  // value method tx_stage1_operands_enq_ena
  assign tx_stage1_operands_enq_ena = MUX_rg_pc_write_1__SEL_1 ;

  // value method tx_stage1_operands_enq_data
  assign tx_stage1_operands_enq_data = { x__h3155, x__h3181 } ;

  // action method tx_stage1_meta_notFull
  assign CAN_FIRE_tx_stage1_meta_notFull = 1'd1 ;
  assign WILL_FIRE_tx_stage1_meta_notFull = 1'd1 ;

  // action method tx_stage1_meta_enq_rdy
  assign CAN_FIRE_tx_stage1_meta_enq_rdy = 1'd1 ;
  assign WILL_FIRE_tx_stage1_meta_enq_rdy = 1'd1 ;

  // value method tx_stage1_meta_enq_ena
  assign tx_stage1_meta_enq_ena = MUX_rg_pc_write_1__SEL_1 ;

  // value method tx_stage1_meta_enq_data
  assign tx_stage1_meta_enq_data =
	     { decoder_func_32___d66[61:44],
	       IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68,
	       decoder_func_32___d66[40:7],
	       x1_avValue_meta_funct__h2931 } ;

  // action method tx_stage1_control_notFull
  assign CAN_FIRE_tx_stage1_control_notFull = 1'd1 ;
  assign WILL_FIRE_tx_stage1_control_notFull = 1'd1 ;

  // action method tx_stage1_control_enq_rdy
  assign CAN_FIRE_tx_stage1_control_enq_rdy = 1'd1 ;
  assign WILL_FIRE_tx_stage1_control_enq_rdy = 1'd1 ;

  // value method tx_stage1_control_enq_ena
  assign tx_stage1_control_enq_ena = MUX_rg_pc_write_1__SEL_1 ;

  // value method tx_stage1_control_enq_data
  assign tx_stage1_control_enq_data = { curr_epoch__h2083, rg_pc } ;

  // action method tx_stage1_dump_notFull
  assign CAN_FIRE_tx_stage1_dump_notFull = 1'd1 ;
  assign WILL_FIRE_tx_stage1_dump_notFull = 1'd1 ;

  // action method tx_stage1_dump_enq_rdy
  assign CAN_FIRE_tx_stage1_dump_enq_rdy = 1'd1 ;
  assign WILL_FIRE_tx_stage1_dump_enq_rdy = 1'd1 ;

  // value method tx_stage1_dump_enq_ena
  assign tx_stage1_dump_enq_ena = MUX_rg_pc_write_1__SEL_1 ;

  // value method tx_stage1_dump_enq_data
  assign tx_stage1_dump_enq_data = { rg_pc, final_instruction__h2887 } ;

  // action method commit_rd_put
  assign RDY_commit_rd_put = !rg_initialize ;
  assign CAN_FIRE_commit_rd_put = !rg_initialize ;
  assign WILL_FIRE_commit_rd_put = EN_commit_rd_put ;

  // action method ma_flush
  assign CAN_FIRE_ma_flush = 1'd1 ;
  assign WILL_FIRE_ma_flush = EN_ma_flush ;

  // action method ma_csr_misa_c
  assign CAN_FIRE_ma_csr_misa_c = 1'd1 ;
  assign WILL_FIRE_ma_csr_misa_c = 1'd1 ;

  // action method ma_interrupt
  assign CAN_FIRE_ma_interrupt = 1'd1 ;
  assign WILL_FIRE_ma_interrupt = 1'd1 ;

  // action method ma_csr_decode
  assign CAN_FIRE_ma_csr_decode = 1'd1 ;
  assign WILL_FIRE_ma_csr_decode = 1'd1 ;

  // action method ma_update_eEpoch
  assign RDY_ma_update_eEpoch = 1'd1 ;
  assign CAN_FIRE_ma_update_eEpoch = 1'd1 ;
  assign WILL_FIRE_ma_update_eEpoch = EN_ma_update_eEpoch ;

  // action method ma_update_wEpoch
  assign RDY_ma_update_wEpoch = 1'd1 ;
  assign CAN_FIRE_ma_update_wEpoch = 1'd1 ;
  assign WILL_FIRE_ma_update_wEpoch = EN_ma_update_wEpoch ;

  // submodule ff_memory_response
  // fifo: to hold the instruction response from the fabric
  FIFO2 #(.width(32'd35), .guarded(1'd1)) ff_memory_response(.RST(RST_N),
							     .CLK(CLK),
							     .D_IN(ff_memory_response_D_IN),
							     .ENQ(ff_memory_response_ENQ),
							     .DEQ(ff_memory_response_DEQ),
							     .CLR(ff_memory_response_CLR),
							     .D_OUT(ff_memory_response_D_OUT),
							     .FULL_N(ff_memory_response_FULL_N),
							     .EMPTY_N(ff_memory_response_EMPTY_N));

  // submodule integer_rf_rf
  RegFile #(.addr_width(32'd5),
	    .data_width(32'd32),
	    .lo(5'd0),
	    .hi(5'd31)) integer_rf_rf(.CLK(CLK),
				      .ADDR_1(integer_rf_rf_ADDR_1),
				      .ADDR_2(integer_rf_rf_ADDR_2),
				      .ADDR_3(integer_rf_rf_ADDR_3),
				      .ADDR_4(integer_rf_rf_ADDR_4),
				      .ADDR_5(integer_rf_rf_ADDR_5),
				      .ADDR_IN(integer_rf_rf_ADDR_IN),
				      .D_IN(integer_rf_rf_D_IN),
				      .WE(integer_rf_rf_WE),
				      .D_OUT_1(integer_rf_rf_D_OUT_1),
				      .D_OUT_2(integer_rf_rf_D_OUT_2),
				      .D_OUT_3(),
				      .D_OUT_4(),
				      .D_OUT_5());

  // rule RL_initialize_regfile
  //   rule: initialize all the registers to 0 on reset
  assign CAN_FIRE_RL_initialize_regfile = rg_initialize ;
  assign WILL_FIRE_RL_initialize_regfile = rg_initialize ;

  // rule RL_wait_for_interrupt
  //   rule:This rule is fired when the core has executed the WFI instruction and waiting     for an intterupt to the core to resume fetch
  assign CAN_FIRE_RL_wait_for_interrupt = rg_wfi && !rg_initialize ;
  assign WILL_FIRE_RL_wait_for_interrupt =
	     CAN_FIRE_RL_wait_for_interrupt && !EN_ma_flush ;

  // rule RL_process_instruction
  //   rule:This rule will receive the instruction from the memory subsystem and decide if     the instruction is compressed or not. The final instruction is then sent to the next stage.    To extract the instruction from the memory response a state machine is implemented.        1. First the epochs are compared and if a mis - match is observed then the response is     dropped without any other changes to the state of the module.    2. if rg_discard is set and compressed is enabled then the lower 16 - bits of the    resposne are discarded and the upper 16 - bits are probed to check if it is a compressed    instruction. If so, then the instruction is sent to the next stage. However is it is not a    compressed instruction it means the upper 16 - bits of the response refer to the lower 16 -    bits of a 32 - bit instruction and thus we will have to wait for the next response from the     cache to form the instruction is send to the next stage. To ensure the concatenation happens     in the next response we set rg_action to ChecPrev and set enque_instruction to False.    3. if rg_action is set to None, then we simply probe the lower 2 - bits to the response to    check if it is compressed. If so then the lower 16 bits form an instruction which is sent to    the next stage, the upper 16 - bits are stored to rg_instruction and rg_action is set to    CheckPrev to ensure that in the next resposne we first probe rg_instruction.    4. if rg_Action if set to CheckPrev then we first probe the lower 2 - bits of the     rg_instruction which leads to two possibilities. Either rg_instruction could hold a    compressed instruction from the previous response, in which case the current memory response    is not dequed and rg_instruction is sent to the next stage. This can happen due to state - 3    mentioned above. The other possibility is that rg_instruction holds the lower 16 - bits of a    32 - bit isntruction, in which case we have concatenate the lower 16 - bits of the response     with rg_instruction and send to the next, and also store the upper 16 - bits of the response     into rg_instruction. rg_Action in this case will remain CheckPrev so that the upper bits of     this repsonse are probed in the next cycle.
  assign CAN_FIRE_RL_process_instruction =
	     ff_memory_response_EMPTY_N && tx_stage1_operands_enq_rdy_b &&
	     tx_stage1_meta_enq_rdy_b &&
	     tx_stage1_control_enq_rdy_b &&
	     tx_stage1_dump_enq_rdy_b &&
	     !rg_wfi &&
	     !rg_initialize ;
  assign WILL_FIRE_RL_process_instruction =
	     CAN_FIRE_RL_process_instruction && !EN_ma_flush ;

  // inputs to muxes for submodule ports
  assign MUX_rg_fabric_request_port1__write_1__SEL_1 =
	     rg_initialize && rg_index == 5'd31 ;
  assign MUX_rg_pc_write_1__SEL_1 =
	     WILL_FIRE_RL_process_instruction &&
	     IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 !=
	     3'd7 &&
	     rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42 ;
  assign MUX_rg_wfi_write_1__SEL_1 =
	     WILL_FIRE_RL_wait_for_interrupt && ma_interrupt_i ;
  assign MUX_rg_fabric_request_port1__write_1__VAL_2 =
	     { ma_flush_newpc[31:2], 2'b0 } ;
  assign MUX_rg_pc_write_1__VAL_1 = rg_pc + 32'd4 ;

  // inlined wires
  assign integer_rf_wr_write_address_whas =
	     rg_initialize || EN_commit_rd_put ;
  assign integer_rf_wr_write_data_whas = EN_commit_rd_put || rg_initialize ;
  assign rg_fabric_request_port0__write_1 = rg_fabric_request + 32'd4 ;
  assign rg_fabric_request_port1__read =
	     EN_inst_request_get ?
	       rg_fabric_request_port0__write_1 :
	       rg_fabric_request ;
  assign rg_fabric_request_EN_port1__write =
	     rg_initialize && rg_index == 5'd31 || EN_ma_flush ;
  assign rg_fabric_request_port1__write_1 =
	     MUX_rg_fabric_request_port1__write_1__SEL_1 ?
	       resetpc :
	       MUX_rg_fabric_request_port1__write_1__VAL_2 ;
  assign rg_fabric_request_port2__read =
	     rg_fabric_request_EN_port1__write ?
	       rg_fabric_request_port1__write_1 :
	       rg_fabric_request_port1__read ;

  // register rg_action
  assign rg_action_D_IN = 1'd1 ;
  assign rg_action_EN =
	     WILL_FIRE_RL_process_instruction &&
	     !rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42 ;

  // register rg_eEpoch
  assign rg_eEpoch_D_IN = ~rg_eEpoch ;
  assign rg_eEpoch_EN = EN_ma_update_eEpoch ;

  // register rg_fabric_request
  assign rg_fabric_request_D_IN = rg_fabric_request_port2__read ;
  assign rg_fabric_request_EN = 1'b1 ;

  // register rg_index
  assign rg_index_D_IN = rg_index + 5'd1 ;
  assign rg_index_EN = rg_initialize ;

  // register rg_initialize
  assign rg_initialize_D_IN = 1'd0 ;
  assign rg_initialize_EN = MUX_rg_fabric_request_port1__write_1__SEL_1 ;

  // register rg_pc
  always@(MUX_rg_pc_write_1__SEL_1 or
	  MUX_rg_pc_write_1__VAL_1 or
	  MUX_rg_fabric_request_port1__write_1__SEL_1 or
	  resetpc or EN_ma_flush or ma_flush_newpc)
  case (1'b1)
    MUX_rg_pc_write_1__SEL_1: rg_pc_D_IN = MUX_rg_pc_write_1__VAL_1;
    MUX_rg_fabric_request_port1__write_1__SEL_1: rg_pc_D_IN = resetpc;
    EN_ma_flush: rg_pc_D_IN = ma_flush_newpc;
    default: rg_pc_D_IN = 32'hAAAAAAAA /* unspecified value */ ;
  endcase
  
  assign rg_pc_EN =
	     WILL_FIRE_RL_process_instruction &&
	     IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 !=
	     3'd7 &&
	     rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42 ||
	     rg_initialize && rg_index == 5'd31 ||
	     EN_ma_flush ;

  // register rg_wEpoch
  assign rg_wEpoch_D_IN = ~rg_wEpoch ;
  assign rg_wEpoch_EN = EN_ma_update_wEpoch ;

  // register rg_wfi
  assign rg_wfi_D_IN = !MUX_rg_wfi_write_1__SEL_1 && !EN_ma_flush ;
  assign rg_wfi_EN =
	     WILL_FIRE_RL_wait_for_interrupt && ma_interrupt_i ||
	     WILL_FIRE_RL_process_instruction &&
	     IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 ==
	     3'd7 &&
	     rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42 ||
	     EN_ma_flush ;

  // submodule ff_memory_response
  assign ff_memory_response_D_IN = inst_response_put ;
  assign ff_memory_response_ENQ = EN_inst_response_put ;
  assign ff_memory_response_DEQ = WILL_FIRE_RL_process_instruction ;
  assign ff_memory_response_CLR = 1'b0 ;

  // submodule integer_rf_rf
  assign integer_rf_rf_ADDR_1 = decoder_func_32___d66[56:52] ;
  assign integer_rf_rf_ADDR_2 = decoder_func_32___d66[61:57] ;
  assign integer_rf_rf_ADDR_3 = 5'h0 ;
  assign integer_rf_rf_ADDR_4 = 5'h0 ;
  assign integer_rf_rf_ADDR_5 = 5'h0 ;
  assign integer_rf_rf_ADDR_IN =
	     rg_initialize ? rg_index : commit_rd_put[36:32] ;
  assign integer_rf_rf_D_IN = rg_initialize ? 32'd0 : commit_rd_put[31:0] ;
  assign integer_rf_rf_WE = integer_rf_wr_write_address_whas ;

  // remaining internal signals
  module_chk_interrupt instance_chk_interrupt_0(.chk_interrupt_prv(ma_csr_decode_c[83:82]),
						.chk_interrupt_mstatus(ma_csr_decode_c[31:0]),
						.chk_interrupt_mip({ 2'd0,
								     x__h2991 }),
						.chk_interrupt_mie(ma_csr_decode_c[69:58]),
						.chk_interrupt(chk_interrupt___d57));
  module_decoder_func_32 instance_decoder_func_32_1(.decoder_func_32_inst(final_instruction__h2887),
						    .decoder_func_32_csrs(ma_csr_decode_c),
						    .decoder_func_32(decoder_func_32___d66));
  assign IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 =
	     (chk_interrupt___d57[1] || ff_memory_response_D_OUT[0]) ?
	       3'd6 :
	       decoder_func_32___d66[43:41] ;
  assign _theResult___fst__h3006 =
	     ff_memory_response_D_OUT[0] ? 7'd1 : decoder_func_32___d66[6:0] ;
  assign curr_epoch__h2083 = { rg_eEpoch, rg_wEpoch } ;
  assign final_instruction__h2887 =
	     rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42 ?
	       v__h2828 :
	       32'd0 ;
  assign func_cause___1__h2999 = { 1'd0, chk_interrupt___d57[7:2] } ;
  assign rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42 =
	     curr_epoch__h2083 == ff_memory_response_D_OUT[2:1] ;
  assign v__h2828 =
	     (ff_memory_response_D_OUT[4:3] == 2'b11) ?
	       ff_memory_response_D_OUT[34:3] :
	       32'd0 ;
  assign x1_avValue_meta_funct__h2931 =
	     chk_interrupt___d57[1] ?
	       func_cause___1__h2999 :
	       _theResult___fst__h3006 ;
  assign x__h2991 = ma_csr_decode_c[81:70] ;
  assign x__h3155 =
	     (decoder_func_32___d66[61:57] == x__read__h916) ?
	       x__read__h987 :
	       integer_rf_rf_D_OUT_2 ;
  assign x__h3181 =
	     (decoder_func_32___d66[56:52] == x__read__h916) ?
	       x__read__h987 :
	       integer_rf_rf_D_OUT_1 ;
  assign x__read__h916 =
	     integer_rf_wr_write_address_whas ? x_wget__h905 : 5'd0 ;
  assign x__read__h987 =
	     integer_rf_wr_write_data_whas ? x_wget__h976 : 32'd0 ;
  assign x_wget__h905 = rg_initialize ? rg_index : commit_rd_put[36:32] ;
  assign x_wget__h976 = EN_commit_rd_put ? commit_rd_put[31:0] : 32'd0 ;

  // handling of inlined registers

  always@(posedge CLK or `BSV_RESET_EDGE RST_N)
  if (RST_N == `BSV_RESET_VALUE)
    begin
      rg_action <= `BSV_ASSIGNMENT_DELAY 1'd1;
      rg_eEpoch <= `BSV_ASSIGNMENT_DELAY 1'd0;
      rg_fabric_request <= `BSV_ASSIGNMENT_DELAY 32'd0;
      rg_index <= `BSV_ASSIGNMENT_DELAY 5'd0;
      rg_initialize <= `BSV_ASSIGNMENT_DELAY 1'd1;
      rg_pc <= `BSV_ASSIGNMENT_DELAY 32'd0;
      rg_wEpoch <= `BSV_ASSIGNMENT_DELAY 1'd0;
      rg_wfi <= `BSV_ASSIGNMENT_DELAY 1'd0;
    end
  else
    begin
      if (rg_action_EN) rg_action <= `BSV_ASSIGNMENT_DELAY rg_action_D_IN;
      if (rg_eEpoch_EN) rg_eEpoch <= `BSV_ASSIGNMENT_DELAY rg_eEpoch_D_IN;
      if (rg_fabric_request_EN)
	rg_fabric_request <= `BSV_ASSIGNMENT_DELAY rg_fabric_request_D_IN;
      if (rg_index_EN) rg_index <= `BSV_ASSIGNMENT_DELAY rg_index_D_IN;
      if (rg_initialize_EN)
	rg_initialize <= `BSV_ASSIGNMENT_DELAY rg_initialize_D_IN;
      if (rg_pc_EN) rg_pc <= `BSV_ASSIGNMENT_DELAY rg_pc_D_IN;
      if (rg_wEpoch_EN) rg_wEpoch <= `BSV_ASSIGNMENT_DELAY rg_wEpoch_D_IN;
      if (rg_wfi_EN) rg_wfi <= `BSV_ASSIGNMENT_DELAY rg_wfi_D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_action = 1'h0;
    rg_eEpoch = 1'h0;
    rg_fabric_request = 32'hAAAAAAAA;
    rg_index = 5'h0A;
    rg_initialize = 1'h0;
    rg_pc = 32'hAAAAAAAA;
    rg_wEpoch = 1'h0;
    rg_wfi = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_commit_rd_put)
	begin
	  TASK_testplusargs___d133 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_commit_rd_put)
	begin
	  TASK_testplusargs___d134 = $test$plusargs("mstage1");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_commit_rd_put)
	begin
	  TASK_testplusargs___d135 = $test$plusargs("l0");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_commit_rd_put)
	begin
	  v__h4560 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_commit_rd_put &&
	  (TASK_testplusargs___d133 ||
	   TASK_testplusargs___d134 && TASK_testplusargs___d135))
	$write("[%10d", v__h4560, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_commit_rd_put &&
	  (TASK_testplusargs___d133 ||
	   TASK_testplusargs___d134 && TASK_testplusargs___d135))
	$write("STAGE1: Writing RF[%d]:%h",
	       commit_rd_put[36:32],
	       commit_rd_put[31:0]);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_commit_rd_put &&
	  (TASK_testplusargs___d133 ||
	   TASK_testplusargs___d134 && TASK_testplusargs___d135))
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_flush)
	begin
	  TASK_testplusargs___d143 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_flush)
	begin
	  TASK_testplusargs___d144 = $test$plusargs("mstage1");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_flush)
	begin
	  TASK_testplusargs___d145 = $test$plusargs("l0");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_flush)
	begin
	  v__h4862 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_flush &&
	  (TASK_testplusargs___d143 ||
	   TASK_testplusargs___d144 && TASK_testplusargs___d145))
	$write("[%10d", v__h4862, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_flush &&
	  (TASK_testplusargs___d143 ||
	   TASK_testplusargs___d144 && TASK_testplusargs___d145))
	$write("STAGE1 : Received Flush. PC: %h ", ma_flush_newpc);
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_ma_flush &&
	  (TASK_testplusargs___d143 ||
	   TASK_testplusargs___d144 && TASK_testplusargs___d145))
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initialize)
	begin
	  TASK_testplusargs___d2 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initialize)
	begin
	  TASK_testplusargs___d3 = $test$plusargs("mstage1");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initialize)
	begin
	  TASK_testplusargs___d4 = $test$plusargs("l1");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initialize)
	begin
	  v__h2173 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initialize &&
	  (TASK_testplusargs___d2 ||
	   TASK_testplusargs___d3 && TASK_testplusargs___d4))
	$write("[%10d", v__h2173, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initialize &&
	  (TASK_testplusargs___d2 ||
	   TASK_testplusargs___d3 && TASK_testplusargs___d4))
	$write("STAGE1: Initializing the RF. Index: %d", rg_index);
    if (RST_N != `BSV_RESET_VALUE)
      if (rg_initialize &&
	  (TASK_testplusargs___d2 ||
	   TASK_testplusargs___d3 && TASK_testplusargs___d4))
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wait_for_interrupt)
	begin
	  TASK_testplusargs___d17 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wait_for_interrupt)
	begin
	  TASK_testplusargs___d18 = $test$plusargs("mstage1");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wait_for_interrupt)
	begin
	  TASK_testplusargs___d19 = $test$plusargs("l0");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wait_for_interrupt)
	begin
	  v__h2552 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wait_for_interrupt &&
	  (TASK_testplusargs___d17 ||
	   TASK_testplusargs___d18 && TASK_testplusargs___d19))
	$write("[%10d", v__h2552, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wait_for_interrupt &&
	  (TASK_testplusargs___d17 ||
	   TASK_testplusargs___d18 && TASK_testplusargs___d19))
	$write("STAGE1 : Waiting for Interrupt. wr_interrupt: %b",
	       ma_interrupt_i);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_wait_for_interrupt &&
	  (TASK_testplusargs___d17 ||
	   TASK_testplusargs___d18 && TASK_testplusargs___d19))
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  !rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  TASK_testplusargs___d44 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  !rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  TASK_testplusargs___d45 = $test$plusargs("mstage1");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  !rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  TASK_testplusargs___d46 = $test$plusargs("l1");
	  #0;
	end
    NOT_rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_mem_ETC___d49 =
	!rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42 &&
	(TASK_testplusargs___d44 ||
	 TASK_testplusargs___d45 && TASK_testplusargs___d46);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  !rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  v__h2746 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_mem_ETC___d49)
	$write("[%10d", v__h2746, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_mem_ETC___d49)
	$write("STAGE1 : Dropping Instruction from Cache");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_mem_ETC___d49)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 != 3'd7 &&
	  rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  TASK_testplusargs___d101 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 != 3'd7 &&
	  rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  TASK_testplusargs___d102 = $test$plusargs("mstage1");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 != 3'd7 &&
	  rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  TASK_testplusargs___d103 = $test$plusargs("l0");
	  #0;
	end
    NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d106 =
	IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 != 3'd7 &&
	rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42 &&
	(TASK_testplusargs___d101 ||
	 TASK_testplusargs___d102 && TASK_testplusargs___d103);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 != 3'd7 &&
	  rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  v__h3486 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d106)
	$write("[%10d", v__h3486, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d106)
	$write("STAGE1 : ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d106)
	$write("TraceDump { ", "pc: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d106)
	$write("'h%h", rg_pc);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d106)
	$write(", ", "instruction: ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d106)
	$write("'h%h", final_instruction__h2887, " }");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d106)
	$write("\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 != 3'd7 &&
	  rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  TASK_testplusargs___d108 = $test$plusargs("fullverbose");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 != 3'd7 &&
	  rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  TASK_testplusargs___d109 = $test$plusargs("mstage1");
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 != 3'd7 &&
	  rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  TASK_testplusargs___d110 = $test$plusargs("l1");
	  #0;
	end
    NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d113 =
	IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 != 3'd7 &&
	rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42 &&
	(TASK_testplusargs___d108 ||
	 TASK_testplusargs___d109 && TASK_testplusargs___d110);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_respon_ETC___d68 != 3'd7 &&
	  rg_eEpoch_7_CONCAT_rg_wEpoch_8_9_EQ_ff_memory__ETC___d42)
	begin
	  v__h3628 = $time;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d113)
	$write("[%10d", v__h3628, "] ");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d113)
	$write("STAGE1 : compressed: %b perform_decode: %b curr_epoch: %b",
	       1'd0,
	       1'd1,
	       curr_epoch__h2083);
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_process_instruction &&
	  NOT_IF_chk_interrupt_7_BIT_1_8_OR_ff_memory_re_ETC___d113)
	$write("\n");
  end
  // synopsys translate_on
endmodule  // mkstage1

